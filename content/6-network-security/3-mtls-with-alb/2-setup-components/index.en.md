---
title : "Setup Solution Components"
weight : 11
---

## Solution Components

This module builds on an existing Amazon EKS cluster, and the steps in the [**Private Hosted Zone**](../../2-vpc-lattice-service-access/2-setup-base-infra/2-private-hosted-zone) **and** [**ACM PCA Infrastructure**](../../2-vpc-lattice-service-access/2-setup-base-infra/3-acm-pca) sections of the previous module.
This module is dedicated to ensuring secure communications between Kubernetes workloads with mTLS in Amazon EKS. 
It covers the following components:

* [**Cert-manager**](https://cert-manager.io/v1.1-docs): is a Kubernetes add-on to automate the management and issuance of TLS certificates from various issuing sources.
* [**AWS Certificate Manager Private CA**](https://docs.aws.amazon.com/acm-pca/latest/userguide/PcaCreateCa.html#create-ca-console-procedure): enables creation of private certificate authority (CA) hierarchies, including root and subordinate CAs, without the investment and maintenance costs of operating an on-premises CA.
* [**Trust store**](https://docs.aws.amazon.com/elasticloadbalancing/latest/application/mutual-authentication.html#create-trust-store): a store where you can upload any CA bundle with roots and/or intermediate certificates generated by AWS Private Certificate Authority or any other third party CA as the source of trust to validate your client certificates.
* [**AWS Private CA Issuer**](https://github.com/cert-manager/aws-privateca-issuer)**:** It is an addon to cert-manager that signs off certificate requests using AWS Private CA.
* [**AWS Load Balancer Controller**](https://kubernetes-sigs.github.io/aws-load-balancer-controller/v2.4/): A Kubernetes controller to help manage Elastic Load Balancers for the Kubernetes cluster
* [**ExternalDNS**](https://kubernetes-sigs.github.io/aws-load-balancer-controller/v2.5/guide/integrations/external_dns/): helps to automatically manage DNS routing of your applications using [Amazon Route 53](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/Welcome.html)
* **Sample Application Deployment**: Deploy a sample workload for an mTLS-enabled service. This workload encompasses the deployment of a sample application configured for mutual TLS (mTLS) within a Kubernetes environment, with a specific focus on Amazon EKS.

## Getting Started

```bash
mkdir -p ~/environment/manifests
```

You need to have completed the steps in the [**Private Hosted Zone**](../../2-vpc-lattice-service-access/2-setup-base-infra/2-private-hosted-zone) **and** [**ACM PCA Infrastructure**](../../2-vpc-lattice-service-access/2-setup-base-infra/3-acm-pca) sections of the previous module before proceeding with this module. If you have completed the sections, check to confirm that the following variables exist in your environment, otherwise complete the highlighted sections in the previous module.

```bash
cat << EOF > data.txt
EKS_CLUSTER: $EKS_CLUSTER 
AWS_REGION: $AWS_REGION 
AWS_ACCOUNT_ID: $AWS_ACCOUNT_ID 
CERTIFICATE_ARN: ${CERTIFICATE_ARN} 
CA_ARN: ${CA_ARN} 
CUSTOM_DOMAIN_NAME: $CUSTOM_DOMAIN_NAME 
HOSTED_ZONE_ID: $HOSTED_ZONE_ID 
EOF
cat data.txt
```

::::expand{header="Check Output"}
```bash
EKS_CLUSTER: eksworkshop-eksctl 
AWS_REGION: us-west-2 
AWS_ACCOUNT_ID: ACCOUNT_ID 
CERTIFICATE_ARN: arn:aws:acm:us-west-2:ACCOUNT_ID:certificate/7d033ce6-d6c9-4fe5-a390-310962937a7a 
CA_ARN: arn:aws:acm-pca:us-west-2:ACCOUNT_ID:certificate-authority/25ea52a2-fd06-4769-a586-d9cee5cdf515 
CUSTOM_DOMAIN_NAME: vpc-lattice-custom-domain.io 
HOSTED_ZONE_ID: /hostedzone/XXXXXXXXXXXXXXX
```
::::

Ensure you switch to the main EKS Cluster

```bash
aws eks update-kubeconfig \
  --region $AWS_REGION  \
  --name $EKS_CLUSTER
```


Get the main cluster VPC

```bash
export VPC_ID=`aws eks describe-cluster --name $EKS_CLUSTER --query 'cluster.resourcesVpcConfig.vpcId' --output text --region $AWS_REGION`  
```

### Create Trust store for the AWS Load Balancer

Create an S3 bucket with a unique name using the command below:

```bash
aws s3 mb s3://mtls-workshop-$(date "+%Y%m%d%H%M%S")
export S3_BUCKET=`aws s3api list-buckets --query "Buckets[].Name" --output text | grep mtls-workshop`
echo $S3_BUCKET
```

The command creates an S3 bucket in the following format:

```bash
mtls-workshop-XXXXXXXXXXXX
```

Enable versioning for the bucket and upload the root certificate you retrieved in the previous lab when setting up ACM PCA Infrastructure. 

```bash
aws s3api put-bucket-versioning --bucket ${S3_BUCKET} --versioning-configuration Status=Enabled
aws s3 cp manifests/root_cert.pem s3://${S3_BUCKET}/trust-store/  
```

Go to [AWS S3 Console](https://s3.console.aws.amazon.com/s3/buckets) to check for the S3 bucket created
![s3-truststore.png](/static/images/6-network-security/3-mtls-with-alb/s3-truststore.png)


Create the trust store:

```bash
export TRUSTORE_ARN=`aws elbv2 create-trust-store --name acm-pca-cert \
    --ca-certificates-bundle-s3-bucket ${S3_BUCKET} \
    --ca-certificates-bundle-s3-key trust-store/root_cert.pem \
    --query 'TrustStores[].TrustStoreArn' --output text`
```

Go to [AWS EC2 Console](https://console.aws.amazon.com/ec2/#TrustStores) to check for the trust store created
![ec2-truststore.png](/static/images/6-network-security/3-mtls-with-alb/ec2-truststore.png)


### **Install AWS Load Balancer Controller**

```bash
eksdemo install aws-lb-controller -c $EKS_CLUSTER
```

Verify the installation

```bash
kubectl get deployment -n awslb aws-load-balancer-controller
```

::::expand{header="Check Output"}

```bash
NAME                           READY   UP-TO-DATE   AVAILABLE   AGE
aws-load-balancer-controller   2/2     2            2           26s
```
::::

**Install and Setup **[External DNS](https://github.com/kubernetes-sigs/external-dns/releases)** in the cluster**

```bash
eksdemo install external-dns -c $EKS_CLUSTER â€”set policy=sync \
--set "domainFilters[0]=vpc-lattice-custom-domain.io" \
--set "txtPrefix=lattice" \
--set "sources[0]=service" --set "sources[1]=ingress" \
--set "extraArgs[0]=--zone-id-filter=$HOSTED_ZONE_ID" \
--set logLevel=debug
```

Confirm that the pod is in running state.

```bash
kubectl get pods -l app.kubernetes.io/name=external-dns -n external-dns
```

::::expand{header="Check Output"}

```bash
NAME                           READY   STATUS    RESTARTS   AGE
external-dns-f4476f786-jnq4m   1/1     Running   0          48s
```
::::

Check logs:

```bash
kubectl logs -f -l app.kubernetes.io/name=external-dns -n external-dns
```

::::expand{header="Check Output"}
```bash
time="2024-04-09T11:04:18Z" level=debug msg="Refreshing zones list cache"
time="2024-04-09T11:04:18Z" level=debug msg="Considering zone: /hostedzone/Z07808962XXK8IZL70GMP (domain: vpc-lattice-custom-domain.io.)"
time="2024-04-09T11:04:18Z" level=debug msg="No endpoints could be generated from service awslb/aws-load-balancer-webhook-service"
time="2024-04-09T11:04:18Z" level=debug msg="No endpoints could be generated from service default/kubernetes"
time="2024-04-09T11:04:18Z" level=debug msg="No endpoints could be generated from service external-dns/external-dns"
time="2024-04-09T11:04:18Z" level=debug msg="No endpoints could be generated from service kube-system/kube-dns"
time="2024-04-09T11:04:18Z" level=debug msg="Refreshing zones list cache"
time="2024-04-09T11:04:18Z" level=debug msg="Considering zone: /hostedzone/Z07808962XXK8IZL70GMP (domain: vpc-lattice-custom-domain.io.)"
time="2024-04-09T11:04:18Z" level=info msg="Applying provider record filter for domains: [vpc-lattice-custom-domain.io. .vpc-lattice-custom-domain.io.]"
time="2024-04-09T11:04:18Z" level=info msg="All records are already up to date"
```
::::

### Verify the Private Certificate Authority

Be sure to complete the steps in [Implementing IAM Auth, TLS, Custom Domains and Multi Cluster Connectivity with Amazon VPC Lattice](../../2-vpc-lattice-service-access) before proceeding with the remainder of steps in this section.

```bash
echo $CA_ARN
```

::::expand{header="Check Output"}
```bash
arn:aws:acm-pca:us-west-2:ACCOUNT_ID:certificate-authority/25ea52a2-fd06-4769-a586-d9cee5cdf515
```
::::

### Install cert manager

```bash
eksdemo install cert-manager -c $EKS_CLUSTER
```

Validate the installation

```bash
kubectl get pods -n cert-manager 
```

::::expand{header="Check Output"}
```bash
NAME                                      READY   STATUS    RESTARTS   AGE
cert-manager-6dc66985d4-x5vkb             1/1     Running   0          22s
cert-manager-cainjector-c7d4dbdd9-mdv7f   1/1     Running   0          22s
cert-manager-webhook-847d7676c9-pjgbc     1/1     Running   0          22s
```
::::

### Install aws-pca-issuer

The AWS PCA Issuer plugin works as an addon to the cert-manager that signs off certificate requests using AWS Certificate Manager Private Certificate Authority. The addon makes it easy to generate certificates for workload inside the Kubernetes cluster.


1. Create file `pca-iam-policy.json` and save the following in it:

```bash
cat << EOF > pca-iam-policy.json
{
    "Version": "2012-10-17",
    "Statement": [
      {
        "Sid": "awspcaissuer",
        "Action": [
          "acm-pca:DescribeCertificateAuthority",
          "acm-pca:GetCertificate",
          "acm-pca:IssueCertificate"
        ],
        "Effect": "Allow",
        "Resource": "${CA_ARN}"
      }
    ]
  }
EOF
```

1. Create and IAM policy called AWSPCAIssuerIAMPolicy with the command below:

```bash
AWSPCA_POLICY_ARN=`aws iam create-policy \
--policy-name AWSPCAIssuerIAMPolicy \
--policy-document file://pca-iam-policy.json \
--query 'Policy.Arn' --output text`
```

1. Create a Service Account for the AWS PCA Issuer plugin with the command below:

```bash
eksctl create iamserviceaccount \
--cluster=$EKS_CLUSTER \
--namespace=default \
--name=aws-pca-issuer \
--attach-policy-arn=$AWSPCA_POLICY_ARN \
--override-existing-serviceaccounts \
--approve
```

1. Add the AWS PCA Issuer Helm repository and run helm install command

```bash
helm repo add awspca https://cert-manager.github.io/aws-privateca-issuer
helm repo update
helm install aws-pca-issuer awspca/aws-privateca-issuer -n default --set serviceAccount.create=false --set serviceAccount.name=aws-pca-issuer
```

1. Verify that AWS PCA issuer is configured correctly by running following command:

```bash
kubectl get pods -l app.kubernetes.io/name=aws-privateca-issuer
```

::::expand{header="Check Output"}

```bash
NAME                                                   READY   STATUS    RESTARTS   AGE
aws-pca-issuer-aws-privateca-issuer-5ddf8ddfd9-sg5zs   1/1     Running   0          69s
```
::::

1. Create the following files for Cluster Issuer and Certificates with your own values

```bash
cat << EOF > cluster-issuer.yaml
apiVersion: awspca.cert-manager.io/v1beta1
kind: AWSPCAClusterIssuer
metadata:
  name: root-ca
spec:
  arn: ${CA_ARN}
  region: ${AWS_REGION}
EOF
kubectl apply -f cluster-issuer.yaml 
```

Confirm that the issuer has been verified and in ready state

```bash
kubectl describe awspcaclusterissuer.awspca.cert-manager.io/root-ca | grep -i status -A5
```

::::expand{header="Check Output"}
```bash
Status:
  Conditions:
    Last Transition Time:  2024-04-09T11:11:12Z
    Message:               Issuer verified
    Reason:                Verified
    Status:                True
    Type:                  Ready
Events:
  Type    Reason    Age                From                     Message
  ----    ------    ----               ----                     -------
  Normal  Verified  23s (x2 over 23s)  awspcaissuer-controller  Issuer verified
```
::::


Generate an end user client certificate signed with AWS PCA
The `mtls-cert.yaml` file will create a secret containing CA certificate along with the Client Certificate that can be used by a client.

```bash
cat << EOF > mtls-cert.yaml
kind: Certificate
apiVersion: cert-manager.io/v1
metadata:
  name: mtls-cert-acm-client
spec:
  commonName: mtls.${CUSTOM_DOMAIN_NAME}
  dnsNames:
    - www.mtls.${CUSTOM_DOMAIN_NAME}
    - mtls.${CUSTOM_DOMAIN_NAME}
  duration: 2160h0m0s
  issuerRef:
    group: awspca.cert-manager.io
    kind: AWSPCAClusterIssuer
    name: root-ca
  renewBefore: 360h0m0s
  secretName: mtls-cert-client
  usages:
    - server auth
    - client auth
  privateKey:
    algorithm: "RSA"
    size: 2048    
EOF
kubectl create namespace mtls
kubectl apply -f mtls-cert.yaml -n mtls
```

1. To confirm that the certificate was successfully issued:

```bash
 kubectl describe certificate.cert-manager.io/mtls-cert-acm-client -n mtls
```

::::expand{header="Check Output"}
```
Name:         mtls-cert-acm-client
Namespace:    mtls
Labels:       <none>
Annotations:  <none>
API Version:  cert-manager.io/v1
Kind:         Certificate
Metadata:
  Creation Timestamp:  2024-04-09T11:12:38Z
  Generation:          1
  Resource Version:    23896
  UID:                 553b4e2d-6985-4312-bc4d-88932c674ee2
Spec:
  Common Name:  mtls.vpc-lattice-custom-domain.io
  Dns Names:
    www.mtls.vpc-lattice-custom-domain.io
    mtls.vpc-lattice-custom-domain.io
  Duration:  2160h0m0s
  Issuer Ref:
    Group:  awspca.cert-manager.io
    Kind:   AWSPCAClusterIssuer
    Name:   root-ca
  Private Key:
    Algorithm:   RSA
    Size:        2048
  Renew Before:  360h0m0s
  Secret Name:   mtls-cert-client
  Usages:
    server auth
    client auth
Status:
  Conditions:
    Last Transition Time:  2024-04-09T11:12:42Z
    Message:               Certificate is up to date and has not expired
    Observed Generation:   1
    Reason:                Ready
    Status:                True
    Type:                  Ready
  Not After:               2024-07-08T11:12:38Z
  Not Before:              2024-04-09T10:12:39Z
  Renewal Time:            2024-06-23T11:12:38Z
  Revision:                1
Events:
  Type    Reason     Age   From                                       Message
  ----    ------     ----  ----                                       -------
  Normal  Issuing    15s   cert-manager-certificates-trigger          Issuing certificate as Secret does not exist
  Normal  Generated  15s   cert-manager-certificates-key-manager      Stored new private key in temporary Secret resource "mtls-cert-acm-client-vdxpx"
  Normal  Requested  15s   cert-manager-certificates-request-manager  Created new CertificateRequest resource "mtls-cert-acm-client-fzknz"
  Normal  Issuing    11s   cert-manager-certificates-issuing          The certificate has been successfully issued
```
::::

Upon the certificate being issued, the certificate data is stored in a secret in the cluster. To view the key pair, run the command below:

```bash
kubectl get secret mtls-cert-client -n mtls -o yaml
```
