---
title : "Setup Solution Components"
weight : 11
---

## Solution Components

This module builds on an existing Amazon EKS cluster, and the steps in the [**Private Hosted Zone**](../../2-vpc-lattice-service-access/2-setup-base-infra/2-private-hosted-zone) **and** [**ACM PCA Infrastructure**](../../2-vpc-lattice-service-access/2-setup-base-infra/3-acm-pca) sections of the previous module.
This module is dedicated to ensuring secure communications between Kubernetes workloads with mTLS in Amazon EKS. 
It covers the following components:

* [**AWS Certificate Manager Private CA**](https://docs.aws.amazon.com/acm-pca/latest/userguide/PcaCreateCa.html#create-ca-console-procedure): enables creation of private certificate authority (CA) hierarchies, including root and subordinate CAs, without the investment and maintenance costs of operating an on-premises CA.
* **Trust store**: a store where you can upload any CA bundle with roots and/or intermediate certificates generated by AWS Private Certificate Authority or any other third party CA as the source of trust to validate your client certificates.
* [**AWS Private CA Issuer**](https://github.com/cert-manager/aws-privateca-issuer)**:** It is an addon to cert-manager that signs off certificate requests using AWS Private CA.
* [**AWS Load Balancer Controller**](https://kubernetes-sigs.github.io/aws-load-balancer-controller/v2.4/): A Kubernetes controller to help manage Elastic Load Balancers for the Kubernetes cluster
* [**Cert-manager**](https://cert-manager.io/v1.1-docs): is a Kubernetes add-on to automate the management and issuance of TLS certificates from various issuing sources.
* [**ExternalDNS**](https://kubernetes-sigs.github.io/aws-load-balancer-controller/v2.5/guide/integrations/external_dns/): helps to automatically manage DNS routing of your applications using [Amazon Route 53](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/Welcome.html)
* **Sample Application Deployment**: Deploy a sample workload for an mTLS-enabled service. This workload encompasses the deployment of a sample application configured for mutual TLS (mTLS) within a Kubernetes environment, with a specific focus on Amazon EKS.

## Getting Started

You need to have completed the steps in the [**Private Hosted Zone**](../../2-vpc-lattice-service-access/2-setup-base-infra/2-private-hosted-zone) **and** [**ACM PCA Infrastructure**](../../2-vpc-lattice-service-access/2-setup-base-infra/3-acm-pca) sections of the previous module before proceeding with this module. If you have completed the sections, check to confirm that the following variables exist in your environment, otherwise complete the highlighted sections in the previous module.

```bash
cat << EOF > data.txt
EKS_CLUSTER: $EKS_CLUSTER 
AWS_REGION: $AWS_REGION 
AWS_ACCOUNT_ID: $AWS_ACCOUNT_ID 
CERTIFICATE_ARN: ${CERTIFICATE_ARN} 
CA_ARN: ${CA_ARN} 
CUSTOM_DOMAIN_NAME: $CUSTOM_DOMAIN_NAME 
HOSTED_ZONE_ID: $HOSTED_ZONE_ID 
EOF
cat data.txt
```

::::expand{header="Check Output"}
```bash
EKS_CLUSTER: eksworkshop-eksctl 
AWS_REGION: us-west-2 
AWS_ACCOUNT_ID: ACCOUNT_ID 
CERTIFICATE_ARN: arn:aws:acm:us-west-2:ACCOUNT_ID:certificate/7d033ce6-d6c9-4fe5-a390-310962937a7a 
CA_ARN: arn:aws:acm-pca:us-west-2:ACCOUNT_ID:certificate-authority/25ea52a2-fd06-4769-a586-d9cee5cdf515 
CUSTOM_DOMAIN_NAME: vpc-lattice-custom-domain.io 
HOSTED_ZONE_ID: /hostedzone/Z10433722R80CQ5CXLVEP 
```
::::

Ensure you switch to the main EKS Cluster

```bash
aws eks update-kubeconfig \
  --region $AWS_REGION  \
  --name $EKS_CLUSTER
```


Get the main cluster VPC

```bash
export VPC_ID=`aws eks describe-cluster --name $EKS_CLUSTER --query 'cluster.resourcesVpcConfig.vpcId' --output text --region $AWS_REGION`  
```

### Create Trust store

Create an S3 bucket with a unique name using the command below:

```bash
aws s3 mb s3://mtls-workshop-$(date "+%Y%m%d%H%M%S")
export S3_BUCKET=`aws s3api list-buckets --query "Buckets[].Name" --output text | grep mtls-workshop`
echo $S3_BUCKET
```

The command creates an S3 bucket in the following format:

```bash
mtls-workshop-XXXXXXXXXXXX
```

::::expand{header="Check Output"}
```bash
${S3_BUCKET}
```
::::

Enable versioning for the bucket and upload the root certificate you retrieved in the previous lab when setting up ACM PCA Infrastructure. 

```bash
aws s3api put-bucket-versioning --bucket ${S3_BUCKET} --versioning-configuration Status=Enabled
aws s3 cp manifests/root_cert.pem s3://${S3_BUCKET}/trust-store/  
```

Go to [AWS S3 Console](https://s3.console.aws.amazon.com/s3/buckets?region=us-west-2) to check for the S3 bucket created
![s3-truststore.png](/static/images/6-network-security/3-mtls-with-alb/s3-truststore.png)


Create the trust store:

```bash
export TRUSTORE_ARN=`aws elbv2 create-trust-store --name acm-pca-cert \
    --ca-certificates-bundle-s3-bucket ${S3_BUCKET} \
    --ca-certificates-bundle-s3-key trust-store/root_cert.pem \
    --query 'TrustStores[].TrustStoreArn' --output text`
```

Go to [AWS EC2 Console](https://us-west-2.console.aws.amazon.com/ec2/home?region=us-west-2#TrustStores:) to check for the trust store created
![ec2-truststore.png](/static/images/6-network-security/3-mtls-with-alb/ec2-truststore.png)


### **Install ALB Controller**

Download an IAM policy for the LBC using one of the following commands:

```bash
curl -o iam-policy.json https://raw.githubusercontent.com/kubernetes-sigs/aws-load-balancer-controller/v2.7.0/docs/install/iam_policy.json
```

Create an IAM policy named `AWSLoadBalancerControllerIAMPolicy`

```bash
ALB_POLICY_ARN=`aws iam create-policy \
--policy-name AWSLoadBalancerControllerIAMPolicy \
--policy-document file://iam-policy.json \
--query 'Policy.Arn' --output text`
```

Create an IAM role and Kubernetes `ServiceAccount` for the LBC. Use the ARN from the previous step.

```bash
eksctl create iamserviceaccount \
--cluster=$EKS_CLUSTER \
--namespace=kube-system \
--name=aws-load-balancer-controller \
--attach-policy-arn=$ALB_POLICY_ARN \
--override-existing-serviceaccounts \
--region $AWS_REGION \
--approve
```

Install ALB Controller using Helm option:

```bash
helm repo add eks https://aws.github.io/eks-charts

helm repo update eks

helm install aws-load-balancer-controller eks/aws-load-balancer-controller \
  -n kube-system \
  --set clusterName=$EKS_CLUSTER \
  --set serviceAccount.create=false \
  --set serviceAccount.name=aws-load-balancer-controller \
  --set region=$AWS_REGION \
  --set vpcId=$VPC_ID
sleep 20
```

Verify the installation

```bash
kubectl get deployment -n kube-system aws-load-balancer-controller
```

::::expand{header="Check Output"}

```bash
NAME                           READY   UP-TO-DATE   AVAILABLE   AGE
aws-load-balancer-controller   2/2     2            2           26s
```
::::

**Install and Setup **[External DNS](https://github.com/kubernetes-sigs/external-dns/releases)** in the cluster**

1. Execute the command below to create file `externaldns-iam-policy.json` :

```bash
cat << EOF > externaldns-iam-policy.json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "route53:ChangeResourceRecordSets"
      ],
      "Resource": [
        "arn:aws:route53:::hostedzone/*"
      ]
    },
    {
      "Effect": "Allow",
      "Action": [
        "route53:ListHostedZones",
        "route53:ListResourceRecordSets",
        "route53:ListTagsForResource"
      ],
      "Resource": [
        "*"
      ]
    }
  ]
}
EOF
```

Create an IAM policy named `AllowExternalDNSUpdates`

```bash
EXTERNAL_DNS_POLICY_ARN=`aws iam create-policy \
--policy-name AllowExternalDNSUpdates \
--policy-document file://externaldns-iam-policy.json \
--query 'Policy.Arn' --output text`
```

Create an IAM role and Kubernetes `ServiceAccount` for the external-dns. Use the ARN from the previous step.

```bash
eksctl create iamserviceaccount \
--cluster=$EKS_CLUSTER \
--namespace=default \
--name=external-dns \
--attach-policy-arn=$EXTERNAL_DNS_POLICY_ARN \
--override-existing-serviceaccounts \
--region $AWS_REGION \
--approve
```

Download sample `external-dns` manifest:

```bash
curl -o external-dns.yaml https://raw.githubusercontent.com/kubernetes-sigs/aws-load-balancer-controller/main/docs/examples/external-dns.yaml
```

Customize the file with your environment

```bash
sed -i "s|my-identifier|$HOSTED_ZONE_ID|g" external-dns.yaml
sed -i "s/external-dns-test.my-org.com/$CUSTOM_DOMAIN_NAME/g" external-dns.yaml
sed -i 's/public/private/g' external-dns.yaml
```

Apply the Kubernetes manifest to setup ExternalDNS in your Kubernetes cluster

```bash
kubectl apply -f external-dns.yaml 
```

Confirm pod

```bash
kubectl get pods -l app.kubernetes.io/name=external-dns
```

::::expand{header="Check Output"}

```bash
NAME                           READY   STATUS    RESTARTS   AGE
external-dns-f4476f786-jnq4m   1/1     Running   0          48s
```
::::

Check logs:

```bash
kubectl logs -f -l app.kubernetes.io/name=external-dns
```

::::expand{header="Check Output"}
```bash
time="2024-03-21T14:04:02Z" level=info msg="Instantiating new Kubernetes client"
time="2024-03-21T14:04:02Z" level=info msg="Using inCluster-config based on serviceaccount-token"
time="2024-03-21T14:04:02Z" level=info msg="Created Kubernetes client https://172.20.0.1:443"
time="2024-03-21T14:04:03Z" level=info msg="Applying provider record filter for domains: [vpc-lattice-custom-domain.io. .vpc-lattice-custom-domain.io.]"
time="2024-03-21T14:04:03Z" level=info msg="All records are already up to date"
time="2024-03-21T14:05:03Z" level=info msg="Applying provider record filter for domains: [vpc-lattice-custom-domain.io. .vpc-lattice-custom-domain.io.]"
time="2024-03-21T14:05:03Z" level=info msg="All records are already up to date"
time="2024-03-21T14:06:04Z" level=info msg="Applying provider record filter for domains: [vpc-lattice-custom-domain.io. .vpc-lattice-custom-domain.io.]"
time="2024-03-21T14:06:04Z" level=info msg="All records are already up to date"
```
::::

### Verify the Private Certificate Authority

Be sure to complete the steps in [Implementing IAM Auth, TLS, Custom Domains and Multi Cluster Connectivity with Amazon VPC Lattice](../../2-vpc-lattice-service-access) before proceeding with the remainder of steps in this section.

```bash
echo $CA_ARN
```

::::expand{header="Check Output"}
```bash
arn:aws:acm-pca:us-west-2:ACCOUNT_ID:certificate-authority/25ea52a2-fd06-4769-a586-d9cee5cdf515
```
::::

### Install cert manager

1. Create file `certmanager-iam-policy.json` and save the following in it:

```bash
export ZONE_ID=${HOSTED_ZONE_ID##*/}
cat << EOF > certmanager-iam-policy.json
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Action": "route53:GetChange",
            "Resource": "arn:aws:route53:::change/*"
        },
        {
            "Effect": "Allow",
            "Action": [
                "route53:ChangeResourceRecordSets",
                "route53:ListResourceRecordSets"
            ],
            "Resource": "arn:aws:route53:::hostedzone/$ZONE_ID"
        }
    ]
}
EOF
```

Create an IAM policy named `PolicyForCertManager`

```bash
CERT_MANAGER_POLICY_ARN=`aws iam create-policy \
--policy-name PolicyForCertManager \
--policy-document file://certmanager-iam-policy.json \
--query 'Policy.Arn' --output text`
```

Create an IAM role and Kubernetes `ServiceAccount` for the cert-manager. Use the ARN from the previous step.

```bash
eksctl create iamserviceaccount \
--cluster=$EKS_CLUSTER \
--namespace=cert-manager \
--name=cert-manager \
--attach-policy-arn=$CERT_MANAGER_POLICY_ARN \
--override-existing-serviceaccounts \
--region $AWS_REGION \
--approve
```

Install the add-on using helm

```bash
helm repo add jetstack https://charts.jetstack.io
helm repo update
helm install \
  cert-manager jetstack/cert-manager \
  --namespace cert-manager \
  --version v1.14.4  \
  --set installCRDs=true \
  --set serviceAccount.create=false \
  --set serviceAccount.name=cert-manager
```


Validate the installation

```bash
kubectl get pods -n cert-manager 
```

::::expand{header="Check Output"}
```bash
NAME                                      READY   STATUS    RESTARTS   AGE
cert-manager-6dc66985d4-x5vkb             1/1     Running   0          22s
cert-manager-cainjector-c7d4dbdd9-mdv7f   1/1     Running   0          22s
cert-manager-webhook-847d7676c9-pjgbc     1/1     Running   0          22s
```
::::

### Install aws-pca-issuer

The AWS PCA Issuer plugin works as an addon to the cert-manager that signs off certificate requests using AWS Certificate Manager Private Certificate Authority. The addon makes it easy to generate certificates for workload inside the Kubernetes cluster.


1. Create file `pca-iam-policy.json` and save the following in it:

```bash
cat << EOF > pca-iam-policy.json
{
    "Version": "2012-10-17",
    "Statement": [
      {
        "Sid": "awspcaissuer",
        "Action": [
          "acm-pca:DescribeCertificateAuthority",
          "acm-pca:GetCertificate",
          "acm-pca:IssueCertificate"
        ],
        "Effect": "Allow",
        "Resource": "${CA_ARN}"
      }
    ]
  }
EOF
```

1. Create and IAM policy called AWSPCAIssuerIAMPolicy with the command below:

```bash
AWSPCA_POLICY_ARN=`aws iam create-policy \
--policy-name AWSPCAIssuerIAMPolicy \
--policy-document file://pca-iam-policy.json \
--query 'Policy.Arn' --output text`
```

1. Create a Service Account for the AWS PCA Issuer plugin with the command below:

```bash
eksctl create iamserviceaccount \
--cluster=$EKS_CLUSTER \
--namespace=default \
--name=aws-pca-issuer \
--attach-policy-arn=$AWSPCA_POLICY_ARN \
--override-existing-serviceaccounts \
--approve
```

1. Add the AWS PCA Issuer Helm repository and run helm install command

```bash
helm repo add awspca https://cert-manager.github.io/aws-privateca-issuer
helm repo update
helm install aws-pca-issuer awspca/aws-privateca-issuer -n default --set serviceAccount.create=false --set serviceAccount.name=aws-pca-issuer
```

1. Verify that AWS PCA issuer is configured correctly by running following command:

```bash
kubectl get pods -l app.kubernetes.io/name=aws-privateca-issuer
```

::::expand{header="Check Output"}

```bash
NAME                                                   READY   STATUS    RESTARTS   AGE
aws-pca-issuer-aws-privateca-issuer-5ddf8ddfd9-sg5zs   1/1     Running   0          69s
```
::::

1. Create the following files for Cluster Issuer and Certificates with your own values

```bash
cat << EOF > cluster-issuer.yaml
apiVersion: awspca.cert-manager.io/v1beta1
kind: AWSPCAClusterIssuer
metadata:
  name: root-ca
spec:
  arn: ${CA_ARN}
  region: ${AWS_REGION}
EOF
kubectl apply -f cluster-issuer.yaml 
```

Confirm that the issuer has been verified and in ready state

```bash
kubectl describe awspcaclusterissuer.awspca.cert-manager.io/root-ca | grep -i status -A4
```

::::expand{header="Check Output"}
```bash
Status:
  Conditions:
    Last Transition Time:  2024-03-21T12:52:29Z
    Message:               Issuer verified
    Reason:                Verified
    Status:                True
    Type:                  Ready
Events:
  Type    Reason    Age                    From                     Message
  ----    ------    ----                   ----                     -------
  Normal  Verified  3m12s (x2 over 3m12s)  awspcaissuer-controller  Issuer verified
```
::::


Generate an end user client certificate signed with AWS PCA
The `mtls-cert.yaml` file will create a secret containing CA certificate along with the Client Certificate that can be used Client Auth which are stored in a Kubernetes secret object. 

```bash
cat << EOF > mtls-cert.yaml
kind: Certificate
apiVersion: cert-manager.io/v1
metadata:
  name: mtls-cert-acm-client
spec:
  commonName: mtls.${CUSTOM_DOMAIN_NAME}
  dnsNames:
    - www.mtls.${CUSTOM_DOMAIN_NAME}
    - mtls.${CUSTOM_DOMAIN_NAME}
  duration: 2160h0m0s
  issuerRef:
    group: awspca.cert-manager.io
    kind: AWSPCAClusterIssuer
    name: root-ca
  renewBefore: 360h0m0s
  secretName: mtls-cert-client
  usages:
    - server auth
    - client auth
  privateKey:
    algorithm: "RSA"
    size: 2048    
EOF
kubectl create namespace mtls
kubectl apply -f mtls-cert.yaml -n mtls
```

1. To confirm that the certificate was successfully issued:

```bash
 kubectl describe certificate.cert-manager.io/mtls-cert-acm-client -n mtls
```

::::expand{header="Check Output"}
```
Name:         mtls-cert-acm-client
Namespace:    mtls
Labels:       <none>
Annotations:  <none>
API Version:  cert-manager.io/v1
Kind:         Certificate
Metadata:
  Creation Timestamp:  2024-03-21T13:01:54Z
  Generation:          1
  Resource Version:    563803
  UID:                 a0113b61-edf3-434f-a37d-414afd0fcc1c
Spec:
  Common Name:  mtls.vpc-lattice-custom-domain.io
  Dns Names:
    www.mtls.vpc-lattice-custom-domain.io
    mtls.vpc-lattice-custom-domain.io
  Duration:  2160h0m0s
  Issuer Ref:
    Group:  awspca.cert-manager.io
    Kind:   AWSPCAClusterIssuer
    Name:   root-ca
  Private Key:
    Algorithm:   RSA
    Size:        2048
  Renew Before:  360h0m0s
  **Secret Name:   mtls-cert-client**
  Usages:
    server auth
    client auth
Status:
  Conditions:
    Last Transition Time:  2024-03-21T13:01:58Z
    Message:               Certificate is up to date and has not expired
    Observed Generation:   1
    Reason:                Ready
    Status:                True
    Type:                  Ready
  Not After:               2024-06-19T13:01:54Z
  Not Before:              2024-03-21T12:01:55Z
  Renewal Time:            2024-06-04T13:01:54Z
  Revision:                1
Events:
  Type    Reason     Age   From                                       Message
  ----    ------     ----  ----                                       -------
  Normal  Issuing    53s   cert-manager-certificates-trigger          Issuing certificate as Secret does not exist
  Normal  Generated  53s   cert-manager-certificates-key-manager      Stored new private key in temporary Secret resource "mtls-cert-acm-client-9mgz7"
  Normal  Requested  53s   cert-manager-certificates-request-manager  Created new CertificateRequest resource "mtls-cert-acm-client-1"
  Normal  Issuing    49s   cert-manager-certificates-issuing          The certificate has been successfully issued
```
::::

Upon the certificate being issued, the certificate data is stored in a secret in the cluster. To view the key pair, run the command below:

```bash
kubectl get secret mtls-cert-client -n mtls -o yaml
```
